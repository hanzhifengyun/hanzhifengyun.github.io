<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="活着 开心就好">
<meta property="og:type" content="website">
<meta property="og:title" content="汉之风云">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="汉之风云">
<meta property="og:description" content="活着 开心就好">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汉之风云">
<meta name="twitter:description" content="活着 开心就好">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 汉之风云 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=57651172";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">汉之风云</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/再续Java线程池/" itemprop="url">
                  Java 线程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-28T15:14:31+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/28/再续Java线程池/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/28/再续Java线程池/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="再续-Java-线程池"><a href="#再续-Java-线程池" class="headerlink" title="再续 Java 线程池"></a>再续 Java 线程池</h1><blockquote>
<p>本文引领大家更深层次的理解线程池的工作原理</p>
<p>大家可以先看看前一篇文章 <a href="http://www.hanzhifengyun.com/2016/02/23/%E5%88%9D%E5%A7%8BJava%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="external"><strong>初识 Java 线程池</strong></a></p>
</blockquote>
<p>相信看过上一篇的朋友们都对常用的四种线程池有基础的概念和它们带来的好处了.那么它们的真正是怎么实现的呢?</p>
<p>上一篇文章提到Java通过Executors来创建四种线程池, 进入源码我们会发现, 真正的线程池的实现为 <code>ThreadPoolExecutor</code> .</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor #\"></a>ThreadPoolExecutor #\</h2><p>public ThreadPoolExecutor(int corePoolSize,<br>  int maximumPoolSize,<br>  long keepAliveTime,<br>  TimeUnit unit,<br>  BlockingQueue\<runnable\> workQueue,<br>  ThreadFactory threadFactory,<br>  RejectedExecutionHandler handler) </runnable\></p>
<p><code>ThreadPoolExecutor</code>的构造函数的参数用来配置线程池, 下面我们一个个来分析:</p>
<ol>
<li><p><code>corePoolSize</code> :线程池的核心线程数, 一般情况下不管有没有任务都会一直在线程池中一直存活, 只有在 <code>ThreadPoolExecutor</code>中的方法 <code>allowCoreThreadTimeOut(boolean value)</code> 设置为 <code>true</code>时, 闲置的核心线程会存在超时机制, 如果在指定时间没有新任务来时, 核心线程也会被终止, 而这个时间间隔由第3个属性 <code>keepAliveTime</code> 指定.</p>
</li>
<li><p><code>maximumPoolSize</code> : 线程池所能容纳的最大线程数, 当活动的线程数达到这个值后, 后续的新任务将会被阻塞.</p>
</li>
<li><p><code>keepAliveTime</code> : 控制线程闲置时的超时时长, 超过则终止该线程. 一般情况下用于非核心线程.只有在 <code>ThreadPoolExecutor</code>中的方法 <code>allowCoreThreadTimeOut(boolean value)</code> 设置为 <code>true</code>时, 也作用于核心线程.</p>
</li>
<li><p><code>unit</code> : 用于指定<code>keepAliveTime</code> 参数的时间单位, <code>TimeUnit</code> 是个enum枚举类型, 常用的有: TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、TimeUnit.SECONDS(秒)和TimeUnit.MILLISECONDS(毫秒)等.</p>
</li>
<li><p><code>workQueue</code> : 线程池的任务队列, 通过线程池的<code>execute(Runnable command)</code>方法会将任务 <code>Runnable</code> 存储在队列中.</p>
</li>
<li><p><code>threadFactory</code> : 线程工厂, 它是一个接口, 就 <code>Thread newThread(Runnable r)</code>一个方法, 用来为线程池创建新线程的功能.</p>
</li>
<li><p><code>handler</code> : 当任务队列已满或者无法成功执行任务时, <code>ThreadPoolExecutor</code> 会通过 <code>handler</code> 的<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>来通知调用者, 默认情况下回抛出一个<code>RejectedExecutionException</code>. 这个参数一般使用默认值,不常用.</p>
</li>
</ol>
<blockquote>
<p>上面是完整的构造函数, <code>ThreadPoolExecutor</code>还提供其他构造函数, 参数6 和 7 是可选的, 不配置则使用默认配置.</p>
</blockquote>
<h2 id="ThreadPoolExecutor-的核心实现-execute"><a href="#ThreadPoolExecutor-的核心实现-execute" class="headerlink" title="ThreadPoolExecutor 的核心实现: execute() #\"></a>ThreadPoolExecutor 的核心实现: execute() #\</h2><hr>
<p> <strong>重头戏来了</strong>,由于源码封装较多,它的代码量也就下面几行:这边直接贴出来</p>
<p>public void execute(Runnable command)<br>if (command == null)<br>throw new NullPointerException();<br>int c = ctl.get();<br>//如果运行中的线程少于核心线程的数量<br>if (workerCountOf(c) \&lt; corePoolSize)<br>//启动一个核心线程来执行任务<br>if (addWorker(command, true))<br>return;<br>//如果增加该线程失败时的情况,继续往下走<br>c = ctl.get();<br>}<br>//如果一个任务被加入任务队列中<br>if (isRunning(c) &amp;&amp; workQueue.offer(command))<br>int recheck = ctl.get();<br>//仍然需要仔细检查我们是否应该添加一个线程(因为上次检查存在的任务可能已经终止),或者在进入这个方法的时候线程池被关闭<br>if (! isRunning(recheck) &amp;&amp; remove(command))<br>reject(command);<br>//然后再次检查有没有正在运行的线程<br>else if (workerCountOf(recheck) == 0)<br>addWorker(null, false);<br>}<br>//如果任务不能被加入任务队列,则尝试添加一个新线程去执行,如果失败了,也许可能任务已被取消或者任务队列已经饱和,所以拒绝任务.<br>else if (!addWorker(command, false))<br>reject(command);<br>}</p>
<blockquote>
<p>ctl 体现了线程池的状态, 其中包含两个字段:<code>workerCount</code>(有效的线程数量) 和 <code>runState</code> (运行状态, 运行中、停止等等)</p>
<p>reject(command)表示通知调用者任务队列已满或者无法成功执行任务</p>
</blockquote>
<p><code>ThreadPoolExecutor</code>执行任务的时候分了三步:</p>
<ol>
<li><p>如果运行中的线程少于核心线程的数量, 启动一个核心线程来执行任务.调用<code>addWorker()</code>时再次检查运行状态和工作线程数量,防止如果增加该线程失败时的情况,则返回false.</p>
</li>
<li><p>如果一个任务被加入任务队列中,仍然需要仔细检查我们是否应该添加一个线程(因为上次检查存在的任务可能已经终止),或者在进入这个方法的时候线程池被关闭.所以重新检查状态,如果需要的话在任务队列被取消的时候拒绝任务,然后再次检查有没有正在运行的线程,如果没有则创建一个新的线程去执行.</p>
</li>
<li><p>如果任务不能被加入任务队列,则尝试添加一个新线程去执行,如果失败了,也许可能任务已被取消或者任务队列已经饱和,所以拒绝任务.</p>
</li>
</ol>
<blockquote>
<p>好啦! 对Java线程池的运行原理也了解的差不多了, 希望对大家的学习有所帮助</p>
<p>最后, 提醒大家,千万别看完就忘了哦, 要学以致用!</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/git-flow/" itemprop="url">
                  git-flow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-27T17:17:22+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/git-flow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/27/git-flow/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="话不多说-关键是这张图"><a href="#话不多说-关键是这张图" class="headerlink" title="话不多说, 关键是这张图!!!!"></a>话不多说, 关键是这张图!!!!</h1><p><img src="http://i.imgur.com/v58Rg6n.png" alt=""><br>这里附上原图截取的网页链接, 本文也引用其内容:<br><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">http://nvie.com/posts/a-successful-git-branching-model/</a></p>
<p>如果对上图看的有点懵懵懂懂的,可以看完下面介绍再回过头来看这张图,感觉会清晰很多.</p>
<hr>
<h1 id="1-Git-Flow-是什么"><a href="#1-Git-Flow-是什么" class="headerlink" title="1.  Git Flow 是什么"></a>1.  Git Flow 是什么</h1><p>(这里给大家简单介绍下概念)<br>Git Flow是构建在Git之上的一个组织软件开发活动的模型，是在Git之上构建的一项软件开发最佳实践。Git Flow是一套使用Git进行源代码管理时的一套行为规范和简化部分Git操作的工具。</p>
<p>2010年5月，在一篇名为“一种成功的Git分支模型”的博文中，@nvie介绍了一种在Git之上的软件开发模型。通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被nwie称为“Git Flow”。</p>
<p>一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用。</p>
<hr>
<h1 id="2-Git-Flow中的分支"><a href="#2-Git-Flow中的分支" class="headerlink" title="2. Git Flow中的分支"></a>2. Git Flow中的分支</h1><p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。</p>
<h2 id="2-1-主分支"><a href="#2-1-主分支" class="headerlink" title="2.1 主分支"></a>2.1 主分支</h2><p>主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支分为master分支和development分支。</p>
<p><img src="http://i.imgur.com/aUDUgPc.png" alt=""></p>
<h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>master分支上存放的应该是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG）。</p>
<h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><p>develop分支是保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码（Nightly build）。因此这个分支有时也可以被称作“integration branch”。</p>
<p>当develop分支上的代码已实现了软件需求说明书中所有的功能，通过了所有的测试后，并且代码已经足够稳定时，就可以将所有的开发成果合并回master分支了。对于master分支上的新提交的代码建议都打上一个新的版本号标签（TAG），供后续代码跟踪使用。</p>
<p>因此，每次将develop分支上的代码合并回master分支时，我们都可以认为一个新的可供在生产环境中部署的版本就产生了。通常而言，“仅在发布新的可供部署的代码时才更新master分支上的代码”是推荐所有人都遵守的行为准则。基于此，理论上说，每当有代码提交到master分支时，我们可以使用Git Hook触发软件自动测试以及生产环境代码的自动更新工作。这些自动化操作将有利于减少新代码发布之后的一些事务性工作。</p>
<h2 id="2-2-辅助分支"><a href="#2-2-辅助分支" class="headerlink" title="2.2  辅助分支"></a>2.2  辅助分支</h2><p>辅助分支是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。这些分支与主分支不同，通常只会在有限的时间范围内存在。</p>
<p>辅助分支包括：</p>
<ul>
<li>用于开发新功能时所使用的feature分支；</li>
<li>用于辅助版本发布的release分支；</li>
<li>用于修正生产代码中的缺陷的hotfix分支。</li>
</ul>
<p>以上这些分支都有固定的使用目的和分支操作限制。从单纯技术的角度说，这些分支与Git其他分支并没有什么区别，但通过命名，我们定义了使用这些分支的方法。</p>
<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>使用规范：</p>
<ul>
<li>可以从develop分支发起feature分支</li>
<li>代码必须合并回develop分支</li>
<li>feature分支的命名可以使用除master，develop，release-<em>，hotfix-</em>之外的任何名称</li>
</ul>
<p>feature分支（有时也可以被叫做“topic分支”）通常是在开发一项新的软件功能的时候使用，这个分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。</p>
<p>一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。</p>
<p><img src="http://i.imgur.com/wgL4xlI.png" alt=""></p>
<h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h3><p>使用规范：</p>
<ul>
<li>可以从develop分支派生</li>
<li>必须合并回develop分支和master分支</li>
<li>分支命名惯例：release-*</li>
</ul>
<p>release分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。</p>
<p>当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。</p>
<p>成功的派生了release分支，并被赋予版本号之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。</p>
<h3 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h3><p>使用规范：</p>
<ul>
<li>可以从master分支派生</li>
<li>必须合并回master分支和develop分支</li>
<li>分支命名惯例：hotfix-*</li>
</ul>
<p>除了是计划外创建的以外，hotfix分支与release分支十分相似：都可以产生一个新的可供在生产环境部署的软件版本。</p>
<p>当生产环境中的软件遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。</p>
<p>这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。</p>
<p><img src="http://i.imgur.com/zNRR6zf.png" alt=""></p>
<hr>
<h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束。应该说，为我们的软件开发提供了一个可供参考的管理模型。Git Flow开发模型让nvie的开发代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>
<p>所谓模型，在不同的开发团队，不同的文化，不同的项目背景情况下都有可能需要进行适当的裁剪或扩充。祝各位好运！</p>
<p>PS：为了简化使用Git Flow模型时Git指令的复杂性，nvie开发出了一套git增强指令集。可以运行于Windows、Linux、Unix和Mac操作系统之下。有兴趣的同学可以去看看。</p>
<p>这里附上github链接.<a href="https://github.com/nvie/gitflow" target="_blank" rel="external">https://github.com/nvie/gitflow</a></p>
<p>希望对大家有所帮助,谢谢!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-27T15:25:13+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/27/hello-world/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>``` bash<br>$ hexo new “My New Post”<br>```</p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>``` bash<br>$ hexo server<br>```</p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p>``` bash<br>$ hexo generate<br>```</p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>``` bash<br>$ hexo deploy<br>```</p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/23/初始Java线程池/" itemprop="url">
                  Java 线程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-23T22:41:32+08:00" content="2016-02-23">
              2016-02-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/23/初始Java线程池/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/23/初始Java线程池/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识-Java-线程池"><a href="#初识-Java-线程池" class="headerlink" title="初识 Java 线程池"></a>初识 Java 线程池</h1><blockquote>
<p>本文引领大家进入线程池的世界</p>
</blockquote>
<p>很多人对线程的认识可能比较熟悉, 知道它能开启一个任务去做某些事情, 那么线程池又是什么鬼? 不着急, 我们先来回顾一下线程的使用.</p>
<h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><p>正常情况下我们使用线程都是用<code>new Thread()</code>来开启一个线程:</p>
<pre><code>new Thread(new Runnable() {
    @Override
    public void run() {
        // TODO Auto-generated method stub
    }
}).start();
</code></pre><p>我们先来看看 <code>new Thread()</code>的弊端：</p>
<ol>
<li>每次<code>new Thread()</code>都会新建对象导致性能差。</li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断。</li>
</ol>
<blockquote>
<p>执行一个异步任务你还只是如上<code>new Thread()</code>吗？ 那你就out太多了，是时候了解Java线程池的使用了~</p>
</blockquote>
<h2 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h2><p>顾名思义, 线程池就是用来管理线程的池子, Java通过Executors提供四种线程池，分别为：</p>
<ol>
<li><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ol>
<p>相比<code>new Thread()</code>，Java提供的线程池的好处在于：</p>
<ol>
<li>重用存在的线程，减少对象创建、消亡的开销，性能更佳。</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ol>
<blockquote>
<p>理论永远不如实践来的实在, 那么我们举栗子说明</p>
</blockquote>
<p>首先我们来看看Thread 的用法:</p>
<pre><code>public class ThreadTest {

    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            try {
                Thread.sleep(index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            new Thread(new Runnable() {

                public void run() {
                    System.out.println(Thread.currentThread().getId() + &quot;&quot;);
                }

            }).start();;
        }
    }

}

//输出结果
11
12
13
14
15
16
17
18
19
20
</code></pre><p>可以看出创建了10个不同的线程, 如果后台任务频繁, 系统哪有那么多资源给你用?</p>
<p>接下来我们来看看线程池是怎么工作的吧..</p>
<h3 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1. newCachedThreadPool"></a>1. newCachedThreadPool</h3><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p>
<pre><code>public class CachedTheardPoolTest {

    public static void main(String[] args) {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            cachedThreadPool.execute(new Runnable() {

                public void run() {
                    System.out.println(Thread.currentThread().getId() + &quot;&quot;);
                }
            });
        }
    }

}

//输出结果
11
11
11
11
11
11
11
11
11
11
</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p>
<h3 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool"></a>2. newFixedThreadPool</h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p>
<pre><code>public class FixedThreadPoolTest {

    public static void main(String[] args) {
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            fixedThreadPool.execute(new Runnable() {

                public void run() {
                    System.out.println(Thread.currentThread().getId() + &quot;&quot;);
                }
            });
        }

    }

}

//输出结果
11
12
13
11
12
13
11
12
13
11
</code></pre><p>因为线程池大小为3,所以只创建三个可用线程,超出的等待之前任务完成后才执行.<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。</p>
<h3 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3. newScheduledThreadPool"></a>3. newScheduledThreadPool</h3><p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p>
<pre><code>public class ScheduledThreadPoolTest {

    public static void main(String[] args) {
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
        //延迟三秒执行
        scheduledThreadPool.schedule(new Runnable() {

            public void run() {
                System.out.println(&quot;delay 3 seconds&quot;);
            }
        }, 3, TimeUnit.SECONDS);

        //延迟1秒后每3秒执行一次
        scheduledThreadPool.scheduleAtFixedRate(new Runnable() {

            public void run() {
                System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
            }
        }, 1, 3, TimeUnit.SECONDS);
    }

}


//输出结果
delay 1 seconds, and excute every 3 seconds
11
delay 3 seconds
12
delay 1 seconds, and excute every 3 seconds
11
delay 1 seconds, and excute every 3 seconds
11
delay 1 seconds, and excute every 3 seconds
11
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
12
delay 1 seconds, and excute every 3 seconds
12
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
14
delay 1 seconds, and excute every 3 seconds
14
</code></pre><p><code>ScheduledExecutorService</code> 比 <code>Timer</code> 更安全，功能更强大哦.</p>
<h3 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4. newSingleThreadExecutor"></a>4. newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p>
<pre><code>public class SingleThreadExecutorTest {

    public static void main(String[] args) {

        ExecutorService singleThreadExecutor = Executors
                .newSingleThreadExecutor();
        for (int i = 0; i &lt; 10; i++) {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            singleThreadExecutor.execute(new Runnable() {
                public void run() {
                    System.out.println(Thread.currentThread().getId() + &quot;&quot;);
                }
            });
        }
    }

}


//输出结果
11
11
11
11
11
11
11
11
11
11
</code></pre><p>结果依次输出，相当于顺序执行各个任务。<br>现行大多数GUI程序都是单线程的。适用于IO操作,不阻塞主线程.</p>
<p><a href="http://download.csdn.net/detail/hanzhifengyun/9423021" target="_blank" rel="external">Demo下载地址</a></p>
<blockquote>
<p>好啦! 对Java线程池的概念大家也了解的差不多了, 希望对大家的学习有所帮助~~~</p>
<p>最后, 提醒大家,千万别看完就忘了哦, 要学以致用!</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/焉逢(皇甫朝云).jpg"
               alt="汉之风云" />
          <p class="site-author-name" itemprop="name">汉之风云</p>
          <p class="site-description motion-element" itemprop="description">活着 开心就好</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hanzhifengyun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/hanzhifengyun" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.sunlianshuang.com" title="John Sun" target="_blank">John Sun</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">汉之风云</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hanzhifengyun"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
